{
  "errors": [],
  "warnings": [],
  "version": "3.0.0",
  "hash": "b8c2309f0dd95ebfe50a",
  "time": 1129,
  "publicPath": "/js/b8c2309f0dd95ebfe50a",
  "assetsByChunkName": {
    "bundle": "bundle.js",
    "sw": "sw.js"
  },
  "assets": [
    {
      "name": "bundle.js",
      "size": 10015,
      "chunks": [
        0
      ],
      "chunkNames": [
        "bundle"
      ],
      "emitted": true
    },
    {
      "name": "sw.js",
      "size": 1042,
      "chunks": [
        1
      ],
      "chunkNames": [
        "sw"
      ],
      "emitted": true
    }
  ],
  "entrypoints": {
    "bundle": {
      "chunks": [
        0
      ],
      "assets": [
        "bundle.js"
      ]
    },
    "sw": {
      "chunks": [
        1
      ],
      "assets": [
        "sw.js"
      ]
    }
  },
  "chunks": [
    {
      "id": 0,
      "rendered": true,
      "initial": true,
      "entry": true,
      "extraAsync": false,
      "size": 30327,
      "names": [
        "bundle"
      ],
      "files": [
        "bundle.js"
      ],
      "hash": "a7947b4b023f5c2b2316",
      "parents": [],
      "modules": [
        {
          "id": 0,
          "identifier": "/home/webreflection/code/create-hyperhtml-app/node_modules/babel-loader/lib/index.js!/home/webreflection/code/create-hyperhtml-app/viper/client/index.js",
          "name": "./viper/client/index.js",
          "index": 0,
          "index2": 2,
          "size": 241,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0
          ],
          "assets": [],
          "issuer": null,
          "issuerId": null,
          "issuerName": null,
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [],
          "usedExports": true,
          "providedExports": null,
          "optimizationBailout": [],
          "depth": 0,
          "source": "var hyperHTML = require('hyperhtml');\nvar uaInfo = require('../view/ua-info.js');\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  document.body.appendChild(uaInfo(hyperHTML.wire(document.body), navigator));\n}, { once: true });"
        },
        {
          "id": 1,
          "identifier": "/home/webreflection/code/create-hyperhtml-app/node_modules/babel-loader/lib/index.js!/home/webreflection/code/create-hyperhtml-app/node_modules/hyperhtml/hyperhtml.js",
          "name": "./node_modules/hyperhtml/hyperhtml.js",
          "index": 1,
          "index2": 0,
          "size": 29615,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0
          ],
          "assets": [],
          "issuer": "/home/webreflection/code/create-hyperhtml-app/node_modules/babel-loader/lib/index.js!/home/webreflection/code/create-hyperhtml-app/viper/client/index.js",
          "issuerId": 0,
          "issuerName": "./viper/client/index.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 0,
              "moduleIdentifier": "/home/webreflection/code/create-hyperhtml-app/node_modules/babel-loader/lib/index.js!/home/webreflection/code/create-hyperhtml-app/viper/client/index.js",
              "module": "./viper/client/index.js",
              "moduleName": "./viper/client/index.js",
              "type": "cjs require",
              "userRequest": "hyperhtml",
              "loc": "1:16-36"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "optimizationBailout": [],
          "depth": 1,
          "source": "var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar hyperHTML = function (globalDocument) {\n  'use strict';\n\n  /*! (c) 2017 Andrea Giammarchi @WebReflection, (MIT) */\n\n  // ---------------------------------------------\n  // hyperHTML Public API\n  // ---------------------------------------------\n\n  // The document must be swap-able at runtime.\n  // Needed by both basicHTML and nativeHTML\n\n  hyperHTML.document = globalDocument;\n\n  // hyperHTML.bind(el) ‚ö°Ô∏è\n  function hyperHTML(template) {\n    var hyper = hypers.get(this);\n    if (!hyper || hyper.template !== (FF ? unique(template) : template)) {\n      hyper = upgrade.apply(this, arguments);\n      hypers.set(this, hyper);\n    }\n    update.apply(hyper.updates, arguments);\n    return this;\n  }\n\n  // hyperHTML.adopt(el) üê£\n  hyperHTML.adopt = function adopt(node) {\n    return function () {\n      notAdopting = false;\n      hyperHTML.apply(node, arguments);\n      notAdopting = true;\n      return node;\n    };\n  };\n\n  // hyperHTML.wire(obj, 'type:ID') ‚û∞\n  hyperHTML.wire = function wire(obj, type) {\n    return arguments.length < 1 ? wireContent('html') : obj == null ? wireContent(type || 'html') : wireWeakly(obj, type || 'html');\n  };\n\n  // - - - - - - - - - - - - - - - - - - - - - - -\n\n  // ---------------------------------------------\n  // Constants\n  // ---------------------------------------------\n\n  // Node.CONSTANTS\n  // without assuming Node is globally available\n  // since this project is used on the backend too\n  var ELEMENT_NODE = 1;\n  var ATTRIBUTE_NODE = 2;\n  var TEXT_NODE = 3;\n  var COMMENT_NODE = 8;\n  var DOCUMENT_FRAGMENT_NODE = 11;\n\n  // SVG related\n  var OWNER_SVG_ELEMENT = 'ownerSVGElement';\n  var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\n  var SHOULD_USE_ATTRIBUTE = /^style$/i;\n  var EXPANDO = '_hyper_html: ';\n  var UID = EXPANDO + (Math.random() * new Date() | 0) + ';';\n  var UIDC = '<!--' + UID + '-->';\n\n  // ---------------------------------------------\n  // DOM Manipulation\n  // ---------------------------------------------\n\n  // return -1 if no differences are found\n  // the index where differences starts otherwise\n  function indexOfDifferences(a, b) {\n    var i = 0,\n        aLength = a.length,\n        bLength = b.length;\n    while (i < aLength) {\n      if (i < bLength && a[i] === b[i]) i++;else return i;\n    }\n    return i === bLength ? -1 : i;\n  }\n\n  // accordingly with the content type\n  // it replace the content of a node\n  // with the give child\n  function populateNode(parent, child) {\n    switch (child.nodeType) {\n      case ELEMENT_NODE:\n        var childNodes = parent.childNodes;\n        if (childNodes[0] === child) {\n          removeNodeList(childNodes, 1);\n          break;\n        }\n        resetAndPopulate(parent, child);\n        break;\n      case DOCUMENT_FRAGMENT_NODE:\n        if (indexOfDifferences(parent.childNodes, child.childNodes) !== -1) {\n          resetAndPopulate(parent, child);\n        }\n        break;\n      case TEXT_NODE:\n        parent.textContent = child.textContent;\n        break;\n    }\n  }\n\n  // remove a list of nodes from startIndex to list.length\n  function removeNodeList(list, startIndex) {\n    var length = list.length,\n        child;\n    while (startIndex < length--) {\n      child = list[length];\n      child.parentNode.removeChild(child);\n    }\n  }\n\n  // erase a node content and populate it\n  function resetAndPopulate(parent, child) {\n    parent.textContent = '';\n    parent.appendChild(child);\n  }\n\n  // append childNodes to a node from a specific index\n  function updateViaArray(node, childNodes, i) {\n    var fragment = emptyFragment(node);\n    if (i !== 0) {\n      removeNodeList(node.childNodes, i);\n      appendNodes(fragment, childNodes.slice(i));\n      node.appendChild(fragment);\n    } else {\n      appendNodes(fragment, childNodes);\n      resetAndPopulate(node, fragment);\n    }\n  }\n\n  // ---------------------------------------------\n  // hyperHTML Operations\n  // ---------------------------------------------\n\n  // `<div>${'any'}</div>`\n  function setAnyContent(node) {\n    return function any(value) {\n      switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {\n        case 'string':\n        case 'number':\n        case 'boolean':\n          node.innerHTML = value;\n          break;\n        case 'function':\n          any(value(node, node.children, 0));\n          break;\n        default:\n          if (isArray(value)) {\n            var i,\n                length = value.length;\n            if (length === 1) {\n              any(value[0]);\n            } else {\n              switch (length === 0 ? '' : _typeof(value[0])) {\n                case 'string':\n                  any(value.join(''));\n                  break;\n                case 'function':\n                  var children = slice.call(node.children);\n                  for (i = 0, length = value.length; i < length; i++) {\n                    value[i] = value[i](node, children, i);\n                  }\n                  removeNodeList(children, i);\n                  any(value.concat.apply([], value));\n                  break;\n                default:\n                  i = indexOfDifferences(node.childNodes, value);\n                  if (i !== -1) updateViaArray(node, value, i);\n                  break;\n              }\n            }\n          } else {\n            populateNode(node, value);\n          }\n          break;\n      }\n    };\n  }\n\n  // `<div class=\"${'attr'}\"></div>`\n  function setAttribute(attribute, removeAttributes) {\n    var name = attribute.name,\n        node = attribute.ownerElement,\n        isEvent = name.slice(0, 2) === 'on',\n        isSpecial = name in node && !(\n    // always use set attribute with SVGs\n    OWNER_SVG_ELEMENT in node || SHOULD_USE_ATTRIBUTE.test(name)),\n        oldValue;\n    if (isSpecial) removeAttributes.push(node, name);\n    return isSpecial ? function specialAttr(newValue) {\n      if (oldValue !== newValue) {\n        if (isEvent && oldValue && 'handleEvent' in oldValue) {\n          handleEvent(node, 'remove', name, oldValue);\n        }\n        oldValue = newValue;\n        if (isEvent && newValue && 'handleEvent' in newValue) {\n          handleEvent(node, 'add', name, newValue);\n        } else {\n          node[name] = newValue;\n        }\n      }\n    } : function attr(newValue) {\n      if (oldValue !== newValue) {\n        oldValue = newValue;\n        attribute.value = newValue;\n      }\n    };\n  }\n\n  // `<div> ${'text'} </div>`\n  function setTextContent(node) {\n    var oldValue;\n    return function text(newValue) {\n      if (oldValue !== newValue) {\n        oldValue = newValue;\n        node.textContent = newValue;\n      }\n    };\n  }\n\n  // `<li>a</li>${'virtual'}<li>c</li>`\n  function setVirtualContent(node, childNodes) {\n    return function anyVirtual(value) {\n      switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {\n        case 'string':\n        case 'number':\n        case 'boolean':\n          removeNodeList(childNodes, 0);\n          var fragment = createFragment(node, value);\n          childNodes = slice.call(fragment.childNodes);\n          node.parentNode.insertBefore(fragment, node);\n          break;\n        case 'function':\n          anyVirtual(value(node.parentNode, childNodes, 0));\n          break;\n        default:\n          if (isArray(value)) {\n            var i,\n                length = value.length;\n            if (length === 0) {\n              removeNodeList(childNodes, 0);\n              childNodes = [];\n            } else {\n              switch (_typeof(value[0])) {\n                case 'string':\n                  anyVirtual(value.join(''));\n                  break;\n                case 'function':\n                  var parentNode = node.parentNode;\n                  for (i = 0, length = value.length; i < length; i++) {\n                    value[i] = value[i](parentNode, childNodes, i);\n                  }\n                  anyVirtual(value.concat.apply([], value));\n                  break;\n                default:\n                  i = indexOfDifferences(childNodes, value);\n                  if (i !== -1) {\n                    var fragment = emptyFragment(node);\n                    removeNodeList(childNodes, i);\n                    value = value.slice(i);\n                    appendNodes(fragment, value);\n                    node.parentNode.insertBefore(fragment, node);\n                    childNodes = childNodes.slice(0, i).concat(value);\n                  }\n                  break;\n              }\n            }\n          } else {\n            removeNodeList(childNodes, 0);\n            childNodes = value.nodeType === DOCUMENT_FRAGMENT_NODE ? slice.call(value.childNodes) : [value];\n            node.parentNode.insertBefore(value, node);\n          }\n          break;\n      }\n    };\n  }\n\n  // ---------------------------------------------\n  // DOM Traversing\n  // ---------------------------------------------\n\n  // look for attributes that contains the comment text\n  function attributesSeeker(node, paths) {\n    for (var attribute, value = IE ? UID : UIDC, attributes = node.attributes, i = 0, length = attributes.length; i < length; i++) {\n      attribute = attributes[i];\n      if (attribute.value === value) {\n        paths.push(Path('attr',\n        // with IE the order doesn't really matter\n        // as long as the right attribute is addressed\n        IE ? node.attributes[IEAttributes.shift()] : attribute));\n      }\n    }\n  }\n\n  // walk the fragment tree in search of comments\n  function commentsSeeker(node, paths) {\n    for (var child, text, childNodes = node.childNodes, length = childNodes.length, i = 0; i < length; i++) {\n      child = childNodes[i];\n      switch (child.nodeType) {\n        case ELEMENT_NODE:\n          attributesSeeker(child, paths);\n          commentsSeeker(child, paths);\n          break;\n        case COMMENT_NODE:\n          if (child.textContent === UID) {\n            if (length === 1) {\n              paths.push(Path('any', node));\n            } else if ((i < 1 || childNodes[i - 1].nodeType === ELEMENT_NODE) && (i + 1 === length || childNodes[i + 1].nodeType === ELEMENT_NODE)) {\n              paths.push(Path('virtual', child));\n            } else {\n              text = createText(child, '');\n              child.parentNode.replaceChild(text, child);\n              paths.push(Path('text', text));\n            }\n          }\n          break;\n        case TEXT_NODE:\n          if (SHOULD_USE_ATTRIBUTE.test(node.nodeName) && child.textContent === UIDC) {\n            paths.push(Path('text', node));\n          }\n          break;\n      }\n    }\n  }\n\n  // ---------------------------------------------\n  // Features detection / ugly UA sniffs\n  // ---------------------------------------------\n\n  // Firefox < 55 has non standard template literals.\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1108941\n  // TODO: is there any better way to feature detect this ?\n  var FF = (typeof navigator === 'undefined' ? 'undefined' : _typeof(navigator)) === 'object' && /Firefox\\/(\\d+)/.test(navigator.userAgent) && parseFloat(RegExp.$1) < 55;\n\n  // If attributes order is shuffled, threat the browser differently\n  // Usually this is a well known IE only limitation but some older FF does the same.\n  var IE = function () {\n    var p = globalDocument.createElement('p');\n    p.innerHTML = '<i data-i=\"\" class=\"\"></i>';\n    return (/class/i.test(p.firstChild.attributes[0].name)\n    );\n  }();\n\n  // ---------------------------------------------\n  // Helpers\n  // ---------------------------------------------\n\n  // used to convert childNodes to Array\n  var slice = [].slice;\n\n  // return a single node or an Array or nodes\n  function createContent(node) {\n    for (var child, content = [], childNodes = node.childNodes, i = 0, length = childNodes.length; i < length; i++) {\n      child = childNodes[i];\n      if (child.nodeType === ELEMENT_NODE || trim.call(child.textContent).length !== 0) {\n        content.push(child);\n      }\n    }\n    return content.length === 1 ? content[0] : content;\n  }\n\n  // given a node, inject some html and return\n  // the resulting template document fragment\n  function createFragment(node, html) {\n    return (OWNER_SVG_ELEMENT in node ? createSVGFragment : createHTMLFragment)(node, html);\n  }\n\n  // create fragment for HTML\n  function createHTMLFragment(node, html) {\n    var fragment;\n    var document = node.ownerDocument;\n    var container = document.createElement('template');\n    var hasContent = 'content' in container;\n    var needsTableWrap = false;\n    if (!hasContent) {\n      // DO NOT MOVE THE FOLLOWING LINE ELSEWHERE\n      fragment = document.createDocumentFragment();\n      // (a jsdom + nodejs tests coverage gotcha)\n\n      // el.innerHTML = '<td></td>'; is not possible\n      // if the content is a partial internal table content\n      // it needs to be wrapped around once injected.\n      // HTMLTemplateElement does not suffer this issue.\n      needsTableWrap = /^[^\\S]*?<(t(?:head|body|foot|r|d|h))/i.test(html);\n    }\n    if (needsTableWrap) {\n      // secure the RegExp.$1 result ASAP to avoid issues\n      // in case a non-browser DOM library uses RegExp internally\n      // when HTML content is injected (basicHTML / jsdom / others...)\n      var selector = RegExp.$1;\n      container.innerHTML = '<table>' + html + '</table>';\n      appendNodes(fragment, slice.call(container.querySelectorAll(selector)));\n    } else {\n      container.innerHTML = html;\n      if (hasContent) {\n        fragment = container.content;\n      } else {\n        appendNodes(fragment, slice.call(container.childNodes));\n      }\n    }\n    return fragment;\n  }\n\n  // create a fragment for SVG\n  function createSVGFragment(node, html) {\n    var document = node.ownerDocument;\n    var fragment = document.createDocumentFragment();\n    var container = document.createElementNS(SVG_NAMESPACE, 'svg');\n    container.innerHTML = html;\n    appendNodes(fragment, slice.call(container.childNodes));\n    return fragment;\n  }\n\n  // given a node, it does what is says\n  function createText(node, text) {\n    return node.ownerDocument.createTextNode(text);\n  }\n\n  // given an info, tries to find out the best option\n  // to replace or update the content\n  function discoverNode(parentNode, virtual, info, childNodes) {\n    for (var target = parentNode, document = parentNode.ownerDocument, path = info.path, virtualNode = getNode(virtual, path), i = 0, length = path.length; i < length; i++) {\n      switch (path[i++]) {\n        case 'attributes':\n          var name = virtualNode.name;\n          if (!parentNode.hasAttribute(name)) {\n            parentNode.setAttribute(name, '');\n          }\n          target = parentNode.attributes[name];\n          break;\n        case 'childNodes':\n          switch (info.type) {\n            // TODO: supports multiple text per element ?\n            case 'text':\n              var before = getTextContent(virtualNode, 'previous');\n              var after = getTextContent(virtualNode, 'next');\n              do {\n                target = parentNode.firstChild;\n                if (target && target.nodeType === TEXT_NODE) {\n                  parentNode.removeChild(target);\n                } else {\n                  break;\n                }\n              } while (target);\n              var fragment = document.createDocumentFragment();\n              if (before.length) {\n                fragment.appendChild(createText(parentNode, before));\n              }\n              target = fragment.appendChild(createText(parentNode, ''));\n              if (after.length) {\n                fragment.appendChild(createText(parentNode, after));\n              }\n              parentNode.insertBefore(fragment, parentNode.firstChild);\n              break;\n            // TODO: supports multiple virtual content per element ?\n            case 'virtual':\n              var children = getChildren(parentNode);\n              var virtualChildren = getChildren(virtualNode.parentNode);\n              target = virtualNode.previousElementSibling;\n              var before = target ? path.indexOf.call(virtualChildren, target) + 1 : -1;\n              target = virtualNode.nextElementSibling;\n              var after = target ? path.indexOf.call(virtualChildren, target) : -1;\n              target = document.createComment(UID);\n              switch (true) {\n                // `${'virtual'}` is actually resolved as `${'any'}`\n                // case before < 0 && after < 0: before = 0;\n\n                // `</a>${'virtual'}`\n                case after < 0:\n                  after = children.length;\n                  break;\n                // `${'virtual'}<b>`\n                case before < 0:\n                  before = 0;\n                // `</a>${'virtual'}<b>`\n                default:\n                  after = -(virtualChildren.length - after);\n                  break;\n              }\n              childNodes.push.apply(childNodes, slice.call(children, before, after));\n              parentNode.insertBefore(target, childNodes.length ? childNodes[childNodes.length - 1].nextElementSibling : slice.call(children, after)[0]);\n              if (childNodes.length === 0) {\n                removePreviousText(parentNode, target);\n              }\n              break;\n          }\n          break;\n        default:\n          // if the node is not there, create it\n          target = getChildren(parentNode)[path[i]] || parentNode.appendChild(parentNode.ownerDocument.createElement(getNode(virtual, path.slice(0, i + 1)).nodeName));\n          parentNode = target;\n          break;\n      }\n    }\n    return target;\n  }\n\n  // create an empty fragment from a generic node\n  function emptyFragment(node) {\n    return node.ownerDocument.createDocumentFragment();\n  }\n\n  // given a node, returns text content before it or after it\n  function getTextContent(node, direction) {\n    var content = [];\n    var method = direction === 'next' ? content.push : content.unshift;\n    do {\n      node = node[direction + 'Sibling'];\n      if (node && node.nodeType === TEXT_NODE) {\n        method.call(content, node.textContent);\n      } else {\n        return content.join('');\n      }\n    } while (true);\n  }\n\n  // add or remove event listeners from a node\n  function handleEvent(node, action, ontype, eventListener) {\n    node[action + 'EventListener'](ontype.slice(2), eventListener);\n  }\n\n  // remove a list of [node, attribute]\n  function removeAttributeList(list) {\n    for (var i = 0, length = list.length; i < length; i++) {\n      list[i++].removeAttribute(list[i]);\n    }\n  }\n\n  // remove all text nodes from a virtual space\n  function removePreviousText(parentNode, node) {\n    var previousSibling = node.previousSibling;\n    if (previousSibling && previousSibling.nodeType === TEXT_NODE) {\n      parentNode.removeChild(previousSibling);\n      removePreviousText(parentNode, node);\n    }\n  }\n\n  // specify the content to update\n  function setContent(type, target, removeAttributes, childNodes) {\n    var update;\n    switch (type) {\n      case 'any':\n        update = setAnyContent(target);\n        break;\n      case 'attr':\n        update = setAttribute(target, removeAttributes);\n        break;\n      case 'text':\n        update = setTextContent(target);\n        break;\n      case 'virtual':\n        update = setVirtualContent(target, childNodes);\n        break;\n    }\n    return update;\n  }\n\n  // used for common path creation.\n  function Path(type, node) {\n    return { type: type, path: createPath(node) };\n  }\n\n  // ---------------------------------------------\n  // Hybrid Shims\n  // ---------------------------------------------\n\n  // WeakMap with partial EXPANDO fallback\n  var $WeakMap = (typeof WeakMap === 'undefined' ? 'undefined' : _typeof(WeakMap)) === (typeof $WeakMap === 'undefined' ? 'undefined' : _typeof($WeakMap)) ? function () {\n    return {\n      get: function get(obj) {\n        return obj[EXPANDO];\n      },\n      set: function set(obj, value) {\n        Object.defineProperty(obj, EXPANDO, {\n          configurable: true,\n          value: value\n        });\n      }\n    };\n  } : WeakMap;\n\n  // Map with partial double Array fallback\n  var $Map = (typeof Map === 'undefined' ? 'undefined' : _typeof(Map)) === (typeof $Map === 'undefined' ? 'undefined' : _typeof($Map)) ? function () {\n    var k = [],\n        v = [];\n    return {\n      get: function get(obj) {\n        return v[k.indexOf(obj)];\n      },\n      // being used with unique template literals\n      // there is never a case when a value is overwritten\n      // no need to check upfront for the indexOf\n      set: function set(obj, value) {\n        v[k.push(obj) - 1] = value;\n      }\n    };\n  } : Map;\n\n  // TODO: which browser needs these partial polyfills here?\n  var isArray = Array.isArray || function () {\n    var toString = {}.toString;\n    // I once had an engine returning [array Array]\n    // and I've got scared since!\n    var s = toString.call([]);\n    return function (a) {\n      return toString.call(a) === s;\n    };\n  }();\n\n  var trim = EXPANDO.trim || function () {\n    return this.replace(/^\\s+|\\s+$/g, '');\n  };\n\n  // ---------------------------------------------\n  // Shared variables\n  // ---------------------------------------------\n\n  // normalize Firefox issue with template literals\n  var templateObjects, unique;\n  if (FF) {\n    templateObjects = Object.create(null);\n    unique = function unique(template) {\n      var key = template.join(UID);\n      return templateObjects[key] || (templateObjects[key] = template);\n    };\n  }\n\n  // use native .append(...childNodes) where available\n  var appendNodes = 'append' in globalDocument ? function (node, childNodes) {\n    node.append.apply(node, childNodes);\n  } : function appendNodes(node, childNodes) {\n    for (var i = 0, length = childNodes.length; i < length; i++) {\n      node.appendChild(childNodes[i]);\n    }\n  };\n\n  // returns children or retrieve them in IE/Edge\n  var getChildren = 'children' in globalDocument ? function (node) {\n    return node.children;\n  } : function (node) {\n    for (var child, children = [], childNodes = node.childNodes, j = 0, i = 0, length = childNodes.length; i < length; i++) {\n      child = childNodes[i];\n      if (child.nodeType === ELEMENT_NODE) children[j++] = child;\n    }\n    return children;\n  };\n\n  // return the correct node walking through a path\n  // fixes IE/Edge issues with attributes and children\n  var getNode = IE ? function (parentNode, path) {\n    for (var name, i = 0, length = path.length; i < length; i++) {\n      name = path[i++];\n      switch (name) {\n        case 'children':\n          parentNode = getChildren(parentNode)[path[i]];\n          break;\n        default:\n          parentNode = parentNode[name][path[i]];\n          break;\n      }\n    }\n    return parentNode;\n  } : function (parentNode, path) {\n    for (var i = 0, length = path.length; i < length; i++) {\n      parentNode = parentNode[path[i++]][path[i]];\n    }\n    return parentNode;\n  };\n\n  // fixes IE problems with comments\n  if (IE) {\n    var IEAttributes;\n    var no = new RegExp('([^\\\\S][a-z]+[a-z0-9_-]*=)([\\'\"])' + UIDC + '\\\\2', 'g');\n    var comments = function comments($0, $1, $2) {\n      IEAttributes.push($1.slice(1, -1));\n      return $1 + $2 + UID + $2;\n    };\n  }\n\n  // [element] = {template, updates};\n  var hypers = new $WeakMap();\n\n  // [element] = {template, updates};\n  var wires = new $WeakMap();\n\n  // [template] = {fragment, paths};\n  var templates = new $Map();\n\n  // internal signal to switch adoption\n  var notAdopting = true;\n\n  // ---------------------------------------------\n  // Template related utilities\n  // ---------------------------------------------\n\n  // given a unique template object\n  // create, parse, and store retrieved info\n  function createTemplate(template) {\n    var paths = [];\n    var html = template.join(UIDC);\n    if (IE) {\n      IEAttributes = [];\n      html = html.replace(no, comments);\n    }\n    var fragment = createFragment(this, html);\n    var info = { fragment: fragment, paths: paths };\n    commentsSeeker(fragment, paths);\n    templates.set(template, info);\n    return info;\n  }\n\n  // given a generic node, returns a path capable\n  // of retrieving such path back again.\n  // TODO: worth passing the index when available ?\n  function createPath(node) {\n    var path = [];\n    var parentNode;\n    switch (node.nodeType) {\n      case ELEMENT_NODE:\n      case DOCUMENT_FRAGMENT_NODE:\n        parentNode = node;\n        break;\n      case TEXT_NODE:\n      case COMMENT_NODE:\n        parentNode = node.parentNode;\n        path.unshift('childNodes', path.indexOf.call(parentNode.childNodes, node));\n        break;\n      case ATTRIBUTE_NODE:\n      default:\n        // jsdom here does not provide a nodeType 2 ...\n        parentNode = node.ownerElement;\n        path.unshift('attributes', node.name);\n        break;\n    }\n    for (node = parentNode; parentNode = parentNode.parentNode; node = parentNode) {\n      path.unshift('children', path.indexOf.call(getChildren(parentNode), node));\n    }\n    return path;\n  }\n\n  // given a root node and a list of paths\n  // creates an array of updates to invoke\n  // whenever the next interpolation happens\n  function createUpdates(fragment, paths) {\n    for (var info, target, updates = [], removeAttributes = [], i = 0, length = paths.length; i < length; i++) {\n      info = paths[i];\n      target = getNode(fragment, info.path);\n      if (target.nodeType === DOCUMENT_FRAGMENT_NODE) {\n        removeNodeList(target.childNodes, 0);\n        target = this;\n      }\n      updates[i] = setContent(info.type, target, removeAttributes, []);\n    }\n    removeAttributeList(removeAttributes);\n    return updates;\n  }\n\n  // like createUpdates but for nodes with already a content\n  function discoverUpdates(fragment, paths) {\n    for (var info, childNodes, updates = [], removeAttributes = [], i = 0, length = paths.length; i < length; i++) {\n      childNodes = [];\n      info = paths[i];\n      updates[i] = setContent(info.type, discoverNode(this, fragment, info, childNodes), removeAttributes, childNodes);\n    }\n    removeAttributeList(removeAttributes);\n    return updates;\n  }\n\n  // invokes each update function passing interpolated value\n  function update() {\n    for (var i = 1, length = arguments.length; i < length; i++) {\n      this[i - 1](arguments[i]);\n    }\n  }\n\n  // create a template, if unknown\n  // upgrade a node to use such template for future updates\n  function upgrade(template) {\n    if (FF) template = unique(template);\n    var updates;\n    var info = templates.get(template) || createTemplate.call(this, template);\n    if (notAdopting) {\n      var fragment = info.fragment.cloneNode(true);\n      updates = createUpdates.call(this, fragment, info.paths);\n      resetAndPopulate(this, fragment);\n    } else {\n      updates = discoverUpdates.call(this, info.fragment, info.paths);\n    }\n    return { template: template, updates: updates };\n  }\n\n  // ---------------------------------------------\n  // Wires\n  // ---------------------------------------------\n\n  // create a new wire for generic DOM content\n  function wireContent(type) {\n    var adopter, content, container, fragment, render, setup, template;\n\n    function before(document) {\n      fragment = document.createDocumentFragment();\n      container = type === 'svg' ? document.createElementNS(SVG_NAMESPACE, 'svg') : fragment;\n      render = hyperHTML.bind(container);\n    }\n\n    function after() {\n      if (setup) {\n        setup = false;\n        if (type === 'svg') {\n          appendNodes(fragment, slice.call(container.childNodes));\n        }\n        content = createContent(fragment);\n      }\n      return content;\n    }\n\n    return type === 'adopt' ? function adopt(statics) {\n      var args = arguments;\n      if (FF) statics = unique(statics);\n      if (template !== statics) {\n        setup = true;\n        template = statics;\n        adopter = function adopter(parentNode, children, i) {\n          if (setup) {\n            if (i < children.length) {\n              container = children[i];\n              fragment = {\n                ownerDocument: container.ownerDocument,\n                childNodes: [container],\n                children: [container]\n              };\n              render = hyperHTML.adopt(fragment);\n            } else {\n              if (OWNER_SVG_ELEMENT in parentNode) type = 'svg';\n              before(parentNode.ownerDocument);\n            }\n          }\n          render.apply(null, args);\n          return after();\n        };\n      }\n      return adopter;\n    } : function update(statics) {\n      if (FF) statics = unique(statics);\n      if (template !== statics) {\n        setup = true;\n        template = statics;\n        before(hyperHTML.document);\n      }\n      render.apply(null, arguments);\n      return after();\n    };\n  }\n\n  // setup a weak reference if needed and return a wire by ID\n  function wireWeakly(obj, type) {\n    var wire = wires.get(obj);\n    var i = type.indexOf(':');\n    var id = type;\n    if (-1 < i) {\n      id = type.slice(i + 1);\n      type = type.slice(0, i) || 'html';\n    }\n    if (!wire) {\n      wire = {};\n      wires.set(obj, wire);\n    }\n    return wire[id] || (wire[id] = wireContent(type));\n  }\n\n  // ---------------------------------------------\n  // ‚ö°Ô∏è Ô∏èÔ∏èThe End ‚û∞\n  // ---------------------------------------------\n  return hyperHTML;\n}(document);\n\n// umd.KISS\ntry {\n  module.exports = hyperHTML;\n} catch (o_O) {}"
        },
        {
          "id": 2,
          "identifier": "/home/webreflection/code/create-hyperhtml-app/node_modules/babel-loader/lib/index.js!/home/webreflection/code/create-hyperhtml-app/viper/view/ua-info.js",
          "name": "./viper/view/ua-info.js",
          "index": 2,
          "index2": 1,
          "size": 471,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0
          ],
          "assets": [],
          "issuer": "/home/webreflection/code/create-hyperhtml-app/node_modules/babel-loader/lib/index.js!/home/webreflection/code/create-hyperhtml-app/viper/client/index.js",
          "issuerId": 0,
          "issuerName": "./viper/client/index.js",
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 0,
              "moduleIdentifier": "/home/webreflection/code/create-hyperhtml-app/node_modules/babel-loader/lib/index.js!/home/webreflection/code/create-hyperhtml-app/viper/client/index.js",
              "module": "./viper/client/index.js",
              "moduleName": "./viper/client/index.js",
              "type": "cjs require",
              "userRequest": "../view/ua-info.js",
              "loc": "2:13-42"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "optimizationBailout": [],
          "depth": 1,
          "source": "var _templateObject = _taggedTemplateLiteral([\"\\n  <p>\\n    Your user agent string is: <br>\\n    \", \"\\n  </p>\\n\"], [\"\\n  <p>\\n    Your user agent string is: <br>\\n    \", \"\\n  </p>\\n\"]);\n\nfunction _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n// what does the index page represent ?\nmodule.exports = function (render, model) {\n  return render(_templateObject, model.userAgent);\n};"
        }
      ],
      "filteredModules": 0,
      "origins": [
        {
          "moduleId": 0,
          "module": "/home/webreflection/code/create-hyperhtml-app/node_modules/babel-loader/lib/index.js!/home/webreflection/code/create-hyperhtml-app/viper/client/index.js",
          "moduleIdentifier": "/home/webreflection/code/create-hyperhtml-app/node_modules/babel-loader/lib/index.js!/home/webreflection/code/create-hyperhtml-app/viper/client/index.js",
          "moduleName": "./viper/client/index.js",
          "loc": "",
          "name": "bundle",
          "reasons": []
        }
      ]
    },
    {
      "id": 1,
      "rendered": true,
      "initial": true,
      "entry": true,
      "extraAsync": false,
      "size": 894,
      "names": [
        "sw"
      ],
      "files": [
        "sw.js"
      ],
      "hash": "4bdb8e881ca37c46e153",
      "parents": [],
      "modules": [
        {
          "id": 3,
          "identifier": "/home/webreflection/code/create-hyperhtml-app/node_modules/babel-loader/lib/index.js!/home/webreflection/code/create-hyperhtml-app/viper/client/sw.js",
          "name": "./viper/client/sw.js",
          "index": 3,
          "index2": 3,
          "size": 894,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            1
          ],
          "assets": [],
          "issuer": null,
          "issuerId": null,
          "issuerName": null,
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [],
          "usedExports": true,
          "providedExports": null,
          "optimizationBailout": [],
          "depth": 0,
          "source": "var openCache = caches.open('#[viper-news]');\nvar any = function any($) {\n  return new Promise(function (D, E, A, L) {\n    A = [];\n    L = $.map(function ($, i) {\n      return Promise.resolve($).then(D, function (O) {\n        return (A[i] = O, --L) || E(A);\n      });\n    }).length;\n  });\n};\n\nself.addEventListener('install', function (e) {\n  e.waitUntil(openCache.then(function (cache) {\n    return cache.addAll([]);\n  }));\n});\n\nself.addEventListener('fetch', function (e) {\n  var request = e.request;\n  e.respondWith(openCache.then(function (cache) {\n    return cache.match(request).then(function (response) {\n      var remote = fetch(request).then(function (response) {\n        if (199 < response.status && response.status < 400) {\n          cache.put(request, response.clone());\n        }\n        return response;\n      });\n      return any([response || remote, remote]);\n    });\n  }));\n});"
        }
      ],
      "filteredModules": 0,
      "origins": [
        {
          "moduleId": 3,
          "module": "/home/webreflection/code/create-hyperhtml-app/node_modules/babel-loader/lib/index.js!/home/webreflection/code/create-hyperhtml-app/viper/client/sw.js",
          "moduleIdentifier": "/home/webreflection/code/create-hyperhtml-app/node_modules/babel-loader/lib/index.js!/home/webreflection/code/create-hyperhtml-app/viper/client/sw.js",
          "moduleName": "./viper/client/sw.js",
          "loc": "",
          "name": "sw",
          "reasons": []
        }
      ]
    }
  ],
  "modules": [
    {
      "id": 0,
      "identifier": "/home/webreflection/code/create-hyperhtml-app/node_modules/babel-loader/lib/index.js!/home/webreflection/code/create-hyperhtml-app/viper/client/index.js",
      "name": "./viper/client/index.js",
      "index": 0,
      "index2": 2,
      "size": 241,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": null,
      "issuerId": null,
      "issuerName": null,
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [],
      "usedExports": true,
      "providedExports": null,
      "optimizationBailout": [],
      "depth": 0,
      "source": "var hyperHTML = require('hyperhtml');\nvar uaInfo = require('../view/ua-info.js');\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  document.body.appendChild(uaInfo(hyperHTML.wire(document.body), navigator));\n}, { once: true });"
    },
    {
      "id": 1,
      "identifier": "/home/webreflection/code/create-hyperhtml-app/node_modules/babel-loader/lib/index.js!/home/webreflection/code/create-hyperhtml-app/node_modules/hyperhtml/hyperhtml.js",
      "name": "./node_modules/hyperhtml/hyperhtml.js",
      "index": 1,
      "index2": 0,
      "size": 29615,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/webreflection/code/create-hyperhtml-app/node_modules/babel-loader/lib/index.js!/home/webreflection/code/create-hyperhtml-app/viper/client/index.js",
      "issuerId": 0,
      "issuerName": "./viper/client/index.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 0,
          "moduleIdentifier": "/home/webreflection/code/create-hyperhtml-app/node_modules/babel-loader/lib/index.js!/home/webreflection/code/create-hyperhtml-app/viper/client/index.js",
          "module": "./viper/client/index.js",
          "moduleName": "./viper/client/index.js",
          "type": "cjs require",
          "userRequest": "hyperhtml",
          "loc": "1:16-36"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "optimizationBailout": [],
      "depth": 1,
      "source": "var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar hyperHTML = function (globalDocument) {\n  'use strict';\n\n  /*! (c) 2017 Andrea Giammarchi @WebReflection, (MIT) */\n\n  // ---------------------------------------------\n  // hyperHTML Public API\n  // ---------------------------------------------\n\n  // The document must be swap-able at runtime.\n  // Needed by both basicHTML and nativeHTML\n\n  hyperHTML.document = globalDocument;\n\n  // hyperHTML.bind(el) ‚ö°Ô∏è\n  function hyperHTML(template) {\n    var hyper = hypers.get(this);\n    if (!hyper || hyper.template !== (FF ? unique(template) : template)) {\n      hyper = upgrade.apply(this, arguments);\n      hypers.set(this, hyper);\n    }\n    update.apply(hyper.updates, arguments);\n    return this;\n  }\n\n  // hyperHTML.adopt(el) üê£\n  hyperHTML.adopt = function adopt(node) {\n    return function () {\n      notAdopting = false;\n      hyperHTML.apply(node, arguments);\n      notAdopting = true;\n      return node;\n    };\n  };\n\n  // hyperHTML.wire(obj, 'type:ID') ‚û∞\n  hyperHTML.wire = function wire(obj, type) {\n    return arguments.length < 1 ? wireContent('html') : obj == null ? wireContent(type || 'html') : wireWeakly(obj, type || 'html');\n  };\n\n  // - - - - - - - - - - - - - - - - - - - - - - -\n\n  // ---------------------------------------------\n  // Constants\n  // ---------------------------------------------\n\n  // Node.CONSTANTS\n  // without assuming Node is globally available\n  // since this project is used on the backend too\n  var ELEMENT_NODE = 1;\n  var ATTRIBUTE_NODE = 2;\n  var TEXT_NODE = 3;\n  var COMMENT_NODE = 8;\n  var DOCUMENT_FRAGMENT_NODE = 11;\n\n  // SVG related\n  var OWNER_SVG_ELEMENT = 'ownerSVGElement';\n  var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\n  var SHOULD_USE_ATTRIBUTE = /^style$/i;\n  var EXPANDO = '_hyper_html: ';\n  var UID = EXPANDO + (Math.random() * new Date() | 0) + ';';\n  var UIDC = '<!--' + UID + '-->';\n\n  // ---------------------------------------------\n  // DOM Manipulation\n  // ---------------------------------------------\n\n  // return -1 if no differences are found\n  // the index where differences starts otherwise\n  function indexOfDifferences(a, b) {\n    var i = 0,\n        aLength = a.length,\n        bLength = b.length;\n    while (i < aLength) {\n      if (i < bLength && a[i] === b[i]) i++;else return i;\n    }\n    return i === bLength ? -1 : i;\n  }\n\n  // accordingly with the content type\n  // it replace the content of a node\n  // with the give child\n  function populateNode(parent, child) {\n    switch (child.nodeType) {\n      case ELEMENT_NODE:\n        var childNodes = parent.childNodes;\n        if (childNodes[0] === child) {\n          removeNodeList(childNodes, 1);\n          break;\n        }\n        resetAndPopulate(parent, child);\n        break;\n      case DOCUMENT_FRAGMENT_NODE:\n        if (indexOfDifferences(parent.childNodes, child.childNodes) !== -1) {\n          resetAndPopulate(parent, child);\n        }\n        break;\n      case TEXT_NODE:\n        parent.textContent = child.textContent;\n        break;\n    }\n  }\n\n  // remove a list of nodes from startIndex to list.length\n  function removeNodeList(list, startIndex) {\n    var length = list.length,\n        child;\n    while (startIndex < length--) {\n      child = list[length];\n      child.parentNode.removeChild(child);\n    }\n  }\n\n  // erase a node content and populate it\n  function resetAndPopulate(parent, child) {\n    parent.textContent = '';\n    parent.appendChild(child);\n  }\n\n  // append childNodes to a node from a specific index\n  function updateViaArray(node, childNodes, i) {\n    var fragment = emptyFragment(node);\n    if (i !== 0) {\n      removeNodeList(node.childNodes, i);\n      appendNodes(fragment, childNodes.slice(i));\n      node.appendChild(fragment);\n    } else {\n      appendNodes(fragment, childNodes);\n      resetAndPopulate(node, fragment);\n    }\n  }\n\n  // ---------------------------------------------\n  // hyperHTML Operations\n  // ---------------------------------------------\n\n  // `<div>${'any'}</div>`\n  function setAnyContent(node) {\n    return function any(value) {\n      switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {\n        case 'string':\n        case 'number':\n        case 'boolean':\n          node.innerHTML = value;\n          break;\n        case 'function':\n          any(value(node, node.children, 0));\n          break;\n        default:\n          if (isArray(value)) {\n            var i,\n                length = value.length;\n            if (length === 1) {\n              any(value[0]);\n            } else {\n              switch (length === 0 ? '' : _typeof(value[0])) {\n                case 'string':\n                  any(value.join(''));\n                  break;\n                case 'function':\n                  var children = slice.call(node.children);\n                  for (i = 0, length = value.length; i < length; i++) {\n                    value[i] = value[i](node, children, i);\n                  }\n                  removeNodeList(children, i);\n                  any(value.concat.apply([], value));\n                  break;\n                default:\n                  i = indexOfDifferences(node.childNodes, value);\n                  if (i !== -1) updateViaArray(node, value, i);\n                  break;\n              }\n            }\n          } else {\n            populateNode(node, value);\n          }\n          break;\n      }\n    };\n  }\n\n  // `<div class=\"${'attr'}\"></div>`\n  function setAttribute(attribute, removeAttributes) {\n    var name = attribute.name,\n        node = attribute.ownerElement,\n        isEvent = name.slice(0, 2) === 'on',\n        isSpecial = name in node && !(\n    // always use set attribute with SVGs\n    OWNER_SVG_ELEMENT in node || SHOULD_USE_ATTRIBUTE.test(name)),\n        oldValue;\n    if (isSpecial) removeAttributes.push(node, name);\n    return isSpecial ? function specialAttr(newValue) {\n      if (oldValue !== newValue) {\n        if (isEvent && oldValue && 'handleEvent' in oldValue) {\n          handleEvent(node, 'remove', name, oldValue);\n        }\n        oldValue = newValue;\n        if (isEvent && newValue && 'handleEvent' in newValue) {\n          handleEvent(node, 'add', name, newValue);\n        } else {\n          node[name] = newValue;\n        }\n      }\n    } : function attr(newValue) {\n      if (oldValue !== newValue) {\n        oldValue = newValue;\n        attribute.value = newValue;\n      }\n    };\n  }\n\n  // `<div> ${'text'} </div>`\n  function setTextContent(node) {\n    var oldValue;\n    return function text(newValue) {\n      if (oldValue !== newValue) {\n        oldValue = newValue;\n        node.textContent = newValue;\n      }\n    };\n  }\n\n  // `<li>a</li>${'virtual'}<li>c</li>`\n  function setVirtualContent(node, childNodes) {\n    return function anyVirtual(value) {\n      switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {\n        case 'string':\n        case 'number':\n        case 'boolean':\n          removeNodeList(childNodes, 0);\n          var fragment = createFragment(node, value);\n          childNodes = slice.call(fragment.childNodes);\n          node.parentNode.insertBefore(fragment, node);\n          break;\n        case 'function':\n          anyVirtual(value(node.parentNode, childNodes, 0));\n          break;\n        default:\n          if (isArray(value)) {\n            var i,\n                length = value.length;\n            if (length === 0) {\n              removeNodeList(childNodes, 0);\n              childNodes = [];\n            } else {\n              switch (_typeof(value[0])) {\n                case 'string':\n                  anyVirtual(value.join(''));\n                  break;\n                case 'function':\n                  var parentNode = node.parentNode;\n                  for (i = 0, length = value.length; i < length; i++) {\n                    value[i] = value[i](parentNode, childNodes, i);\n                  }\n                  anyVirtual(value.concat.apply([], value));\n                  break;\n                default:\n                  i = indexOfDifferences(childNodes, value);\n                  if (i !== -1) {\n                    var fragment = emptyFragment(node);\n                    removeNodeList(childNodes, i);\n                    value = value.slice(i);\n                    appendNodes(fragment, value);\n                    node.parentNode.insertBefore(fragment, node);\n                    childNodes = childNodes.slice(0, i).concat(value);\n                  }\n                  break;\n              }\n            }\n          } else {\n            removeNodeList(childNodes, 0);\n            childNodes = value.nodeType === DOCUMENT_FRAGMENT_NODE ? slice.call(value.childNodes) : [value];\n            node.parentNode.insertBefore(value, node);\n          }\n          break;\n      }\n    };\n  }\n\n  // ---------------------------------------------\n  // DOM Traversing\n  // ---------------------------------------------\n\n  // look for attributes that contains the comment text\n  function attributesSeeker(node, paths) {\n    for (var attribute, value = IE ? UID : UIDC, attributes = node.attributes, i = 0, length = attributes.length; i < length; i++) {\n      attribute = attributes[i];\n      if (attribute.value === value) {\n        paths.push(Path('attr',\n        // with IE the order doesn't really matter\n        // as long as the right attribute is addressed\n        IE ? node.attributes[IEAttributes.shift()] : attribute));\n      }\n    }\n  }\n\n  // walk the fragment tree in search of comments\n  function commentsSeeker(node, paths) {\n    for (var child, text, childNodes = node.childNodes, length = childNodes.length, i = 0; i < length; i++) {\n      child = childNodes[i];\n      switch (child.nodeType) {\n        case ELEMENT_NODE:\n          attributesSeeker(child, paths);\n          commentsSeeker(child, paths);\n          break;\n        case COMMENT_NODE:\n          if (child.textContent === UID) {\n            if (length === 1) {\n              paths.push(Path('any', node));\n            } else if ((i < 1 || childNodes[i - 1].nodeType === ELEMENT_NODE) && (i + 1 === length || childNodes[i + 1].nodeType === ELEMENT_NODE)) {\n              paths.push(Path('virtual', child));\n            } else {\n              text = createText(child, '');\n              child.parentNode.replaceChild(text, child);\n              paths.push(Path('text', text));\n            }\n          }\n          break;\n        case TEXT_NODE:\n          if (SHOULD_USE_ATTRIBUTE.test(node.nodeName) && child.textContent === UIDC) {\n            paths.push(Path('text', node));\n          }\n          break;\n      }\n    }\n  }\n\n  // ---------------------------------------------\n  // Features detection / ugly UA sniffs\n  // ---------------------------------------------\n\n  // Firefox < 55 has non standard template literals.\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1108941\n  // TODO: is there any better way to feature detect this ?\n  var FF = (typeof navigator === 'undefined' ? 'undefined' : _typeof(navigator)) === 'object' && /Firefox\\/(\\d+)/.test(navigator.userAgent) && parseFloat(RegExp.$1) < 55;\n\n  // If attributes order is shuffled, threat the browser differently\n  // Usually this is a well known IE only limitation but some older FF does the same.\n  var IE = function () {\n    var p = globalDocument.createElement('p');\n    p.innerHTML = '<i data-i=\"\" class=\"\"></i>';\n    return (/class/i.test(p.firstChild.attributes[0].name)\n    );\n  }();\n\n  // ---------------------------------------------\n  // Helpers\n  // ---------------------------------------------\n\n  // used to convert childNodes to Array\n  var slice = [].slice;\n\n  // return a single node or an Array or nodes\n  function createContent(node) {\n    for (var child, content = [], childNodes = node.childNodes, i = 0, length = childNodes.length; i < length; i++) {\n      child = childNodes[i];\n      if (child.nodeType === ELEMENT_NODE || trim.call(child.textContent).length !== 0) {\n        content.push(child);\n      }\n    }\n    return content.length === 1 ? content[0] : content;\n  }\n\n  // given a node, inject some html and return\n  // the resulting template document fragment\n  function createFragment(node, html) {\n    return (OWNER_SVG_ELEMENT in node ? createSVGFragment : createHTMLFragment)(node, html);\n  }\n\n  // create fragment for HTML\n  function createHTMLFragment(node, html) {\n    var fragment;\n    var document = node.ownerDocument;\n    var container = document.createElement('template');\n    var hasContent = 'content' in container;\n    var needsTableWrap = false;\n    if (!hasContent) {\n      // DO NOT MOVE THE FOLLOWING LINE ELSEWHERE\n      fragment = document.createDocumentFragment();\n      // (a jsdom + nodejs tests coverage gotcha)\n\n      // el.innerHTML = '<td></td>'; is not possible\n      // if the content is a partial internal table content\n      // it needs to be wrapped around once injected.\n      // HTMLTemplateElement does not suffer this issue.\n      needsTableWrap = /^[^\\S]*?<(t(?:head|body|foot|r|d|h))/i.test(html);\n    }\n    if (needsTableWrap) {\n      // secure the RegExp.$1 result ASAP to avoid issues\n      // in case a non-browser DOM library uses RegExp internally\n      // when HTML content is injected (basicHTML / jsdom / others...)\n      var selector = RegExp.$1;\n      container.innerHTML = '<table>' + html + '</table>';\n      appendNodes(fragment, slice.call(container.querySelectorAll(selector)));\n    } else {\n      container.innerHTML = html;\n      if (hasContent) {\n        fragment = container.content;\n      } else {\n        appendNodes(fragment, slice.call(container.childNodes));\n      }\n    }\n    return fragment;\n  }\n\n  // create a fragment for SVG\n  function createSVGFragment(node, html) {\n    var document = node.ownerDocument;\n    var fragment = document.createDocumentFragment();\n    var container = document.createElementNS(SVG_NAMESPACE, 'svg');\n    container.innerHTML = html;\n    appendNodes(fragment, slice.call(container.childNodes));\n    return fragment;\n  }\n\n  // given a node, it does what is says\n  function createText(node, text) {\n    return node.ownerDocument.createTextNode(text);\n  }\n\n  // given an info, tries to find out the best option\n  // to replace or update the content\n  function discoverNode(parentNode, virtual, info, childNodes) {\n    for (var target = parentNode, document = parentNode.ownerDocument, path = info.path, virtualNode = getNode(virtual, path), i = 0, length = path.length; i < length; i++) {\n      switch (path[i++]) {\n        case 'attributes':\n          var name = virtualNode.name;\n          if (!parentNode.hasAttribute(name)) {\n            parentNode.setAttribute(name, '');\n          }\n          target = parentNode.attributes[name];\n          break;\n        case 'childNodes':\n          switch (info.type) {\n            // TODO: supports multiple text per element ?\n            case 'text':\n              var before = getTextContent(virtualNode, 'previous');\n              var after = getTextContent(virtualNode, 'next');\n              do {\n                target = parentNode.firstChild;\n                if (target && target.nodeType === TEXT_NODE) {\n                  parentNode.removeChild(target);\n                } else {\n                  break;\n                }\n              } while (target);\n              var fragment = document.createDocumentFragment();\n              if (before.length) {\n                fragment.appendChild(createText(parentNode, before));\n              }\n              target = fragment.appendChild(createText(parentNode, ''));\n              if (after.length) {\n                fragment.appendChild(createText(parentNode, after));\n              }\n              parentNode.insertBefore(fragment, parentNode.firstChild);\n              break;\n            // TODO: supports multiple virtual content per element ?\n            case 'virtual':\n              var children = getChildren(parentNode);\n              var virtualChildren = getChildren(virtualNode.parentNode);\n              target = virtualNode.previousElementSibling;\n              var before = target ? path.indexOf.call(virtualChildren, target) + 1 : -1;\n              target = virtualNode.nextElementSibling;\n              var after = target ? path.indexOf.call(virtualChildren, target) : -1;\n              target = document.createComment(UID);\n              switch (true) {\n                // `${'virtual'}` is actually resolved as `${'any'}`\n                // case before < 0 && after < 0: before = 0;\n\n                // `</a>${'virtual'}`\n                case after < 0:\n                  after = children.length;\n                  break;\n                // `${'virtual'}<b>`\n                case before < 0:\n                  before = 0;\n                // `</a>${'virtual'}<b>`\n                default:\n                  after = -(virtualChildren.length - after);\n                  break;\n              }\n              childNodes.push.apply(childNodes, slice.call(children, before, after));\n              parentNode.insertBefore(target, childNodes.length ? childNodes[childNodes.length - 1].nextElementSibling : slice.call(children, after)[0]);\n              if (childNodes.length === 0) {\n                removePreviousText(parentNode, target);\n              }\n              break;\n          }\n          break;\n        default:\n          // if the node is not there, create it\n          target = getChildren(parentNode)[path[i]] || parentNode.appendChild(parentNode.ownerDocument.createElement(getNode(virtual, path.slice(0, i + 1)).nodeName));\n          parentNode = target;\n          break;\n      }\n    }\n    return target;\n  }\n\n  // create an empty fragment from a generic node\n  function emptyFragment(node) {\n    return node.ownerDocument.createDocumentFragment();\n  }\n\n  // given a node, returns text content before it or after it\n  function getTextContent(node, direction) {\n    var content = [];\n    var method = direction === 'next' ? content.push : content.unshift;\n    do {\n      node = node[direction + 'Sibling'];\n      if (node && node.nodeType === TEXT_NODE) {\n        method.call(content, node.textContent);\n      } else {\n        return content.join('');\n      }\n    } while (true);\n  }\n\n  // add or remove event listeners from a node\n  function handleEvent(node, action, ontype, eventListener) {\n    node[action + 'EventListener'](ontype.slice(2), eventListener);\n  }\n\n  // remove a list of [node, attribute]\n  function removeAttributeList(list) {\n    for (var i = 0, length = list.length; i < length; i++) {\n      list[i++].removeAttribute(list[i]);\n    }\n  }\n\n  // remove all text nodes from a virtual space\n  function removePreviousText(parentNode, node) {\n    var previousSibling = node.previousSibling;\n    if (previousSibling && previousSibling.nodeType === TEXT_NODE) {\n      parentNode.removeChild(previousSibling);\n      removePreviousText(parentNode, node);\n    }\n  }\n\n  // specify the content to update\n  function setContent(type, target, removeAttributes, childNodes) {\n    var update;\n    switch (type) {\n      case 'any':\n        update = setAnyContent(target);\n        break;\n      case 'attr':\n        update = setAttribute(target, removeAttributes);\n        break;\n      case 'text':\n        update = setTextContent(target);\n        break;\n      case 'virtual':\n        update = setVirtualContent(target, childNodes);\n        break;\n    }\n    return update;\n  }\n\n  // used for common path creation.\n  function Path(type, node) {\n    return { type: type, path: createPath(node) };\n  }\n\n  // ---------------------------------------------\n  // Hybrid Shims\n  // ---------------------------------------------\n\n  // WeakMap with partial EXPANDO fallback\n  var $WeakMap = (typeof WeakMap === 'undefined' ? 'undefined' : _typeof(WeakMap)) === (typeof $WeakMap === 'undefined' ? 'undefined' : _typeof($WeakMap)) ? function () {\n    return {\n      get: function get(obj) {\n        return obj[EXPANDO];\n      },\n      set: function set(obj, value) {\n        Object.defineProperty(obj, EXPANDO, {\n          configurable: true,\n          value: value\n        });\n      }\n    };\n  } : WeakMap;\n\n  // Map with partial double Array fallback\n  var $Map = (typeof Map === 'undefined' ? 'undefined' : _typeof(Map)) === (typeof $Map === 'undefined' ? 'undefined' : _typeof($Map)) ? function () {\n    var k = [],\n        v = [];\n    return {\n      get: function get(obj) {\n        return v[k.indexOf(obj)];\n      },\n      // being used with unique template literals\n      // there is never a case when a value is overwritten\n      // no need to check upfront for the indexOf\n      set: function set(obj, value) {\n        v[k.push(obj) - 1] = value;\n      }\n    };\n  } : Map;\n\n  // TODO: which browser needs these partial polyfills here?\n  var isArray = Array.isArray || function () {\n    var toString = {}.toString;\n    // I once had an engine returning [array Array]\n    // and I've got scared since!\n    var s = toString.call([]);\n    return function (a) {\n      return toString.call(a) === s;\n    };\n  }();\n\n  var trim = EXPANDO.trim || function () {\n    return this.replace(/^\\s+|\\s+$/g, '');\n  };\n\n  // ---------------------------------------------\n  // Shared variables\n  // ---------------------------------------------\n\n  // normalize Firefox issue with template literals\n  var templateObjects, unique;\n  if (FF) {\n    templateObjects = Object.create(null);\n    unique = function unique(template) {\n      var key = template.join(UID);\n      return templateObjects[key] || (templateObjects[key] = template);\n    };\n  }\n\n  // use native .append(...childNodes) where available\n  var appendNodes = 'append' in globalDocument ? function (node, childNodes) {\n    node.append.apply(node, childNodes);\n  } : function appendNodes(node, childNodes) {\n    for (var i = 0, length = childNodes.length; i < length; i++) {\n      node.appendChild(childNodes[i]);\n    }\n  };\n\n  // returns children or retrieve them in IE/Edge\n  var getChildren = 'children' in globalDocument ? function (node) {\n    return node.children;\n  } : function (node) {\n    for (var child, children = [], childNodes = node.childNodes, j = 0, i = 0, length = childNodes.length; i < length; i++) {\n      child = childNodes[i];\n      if (child.nodeType === ELEMENT_NODE) children[j++] = child;\n    }\n    return children;\n  };\n\n  // return the correct node walking through a path\n  // fixes IE/Edge issues with attributes and children\n  var getNode = IE ? function (parentNode, path) {\n    for (var name, i = 0, length = path.length; i < length; i++) {\n      name = path[i++];\n      switch (name) {\n        case 'children':\n          parentNode = getChildren(parentNode)[path[i]];\n          break;\n        default:\n          parentNode = parentNode[name][path[i]];\n          break;\n      }\n    }\n    return parentNode;\n  } : function (parentNode, path) {\n    for (var i = 0, length = path.length; i < length; i++) {\n      parentNode = parentNode[path[i++]][path[i]];\n    }\n    return parentNode;\n  };\n\n  // fixes IE problems with comments\n  if (IE) {\n    var IEAttributes;\n    var no = new RegExp('([^\\\\S][a-z]+[a-z0-9_-]*=)([\\'\"])' + UIDC + '\\\\2', 'g');\n    var comments = function comments($0, $1, $2) {\n      IEAttributes.push($1.slice(1, -1));\n      return $1 + $2 + UID + $2;\n    };\n  }\n\n  // [element] = {template, updates};\n  var hypers = new $WeakMap();\n\n  // [element] = {template, updates};\n  var wires = new $WeakMap();\n\n  // [template] = {fragment, paths};\n  var templates = new $Map();\n\n  // internal signal to switch adoption\n  var notAdopting = true;\n\n  // ---------------------------------------------\n  // Template related utilities\n  // ---------------------------------------------\n\n  // given a unique template object\n  // create, parse, and store retrieved info\n  function createTemplate(template) {\n    var paths = [];\n    var html = template.join(UIDC);\n    if (IE) {\n      IEAttributes = [];\n      html = html.replace(no, comments);\n    }\n    var fragment = createFragment(this, html);\n    var info = { fragment: fragment, paths: paths };\n    commentsSeeker(fragment, paths);\n    templates.set(template, info);\n    return info;\n  }\n\n  // given a generic node, returns a path capable\n  // of retrieving such path back again.\n  // TODO: worth passing the index when available ?\n  function createPath(node) {\n    var path = [];\n    var parentNode;\n    switch (node.nodeType) {\n      case ELEMENT_NODE:\n      case DOCUMENT_FRAGMENT_NODE:\n        parentNode = node;\n        break;\n      case TEXT_NODE:\n      case COMMENT_NODE:\n        parentNode = node.parentNode;\n        path.unshift('childNodes', path.indexOf.call(parentNode.childNodes, node));\n        break;\n      case ATTRIBUTE_NODE:\n      default:\n        // jsdom here does not provide a nodeType 2 ...\n        parentNode = node.ownerElement;\n        path.unshift('attributes', node.name);\n        break;\n    }\n    for (node = parentNode; parentNode = parentNode.parentNode; node = parentNode) {\n      path.unshift('children', path.indexOf.call(getChildren(parentNode), node));\n    }\n    return path;\n  }\n\n  // given a root node and a list of paths\n  // creates an array of updates to invoke\n  // whenever the next interpolation happens\n  function createUpdates(fragment, paths) {\n    for (var info, target, updates = [], removeAttributes = [], i = 0, length = paths.length; i < length; i++) {\n      info = paths[i];\n      target = getNode(fragment, info.path);\n      if (target.nodeType === DOCUMENT_FRAGMENT_NODE) {\n        removeNodeList(target.childNodes, 0);\n        target = this;\n      }\n      updates[i] = setContent(info.type, target, removeAttributes, []);\n    }\n    removeAttributeList(removeAttributes);\n    return updates;\n  }\n\n  // like createUpdates but for nodes with already a content\n  function discoverUpdates(fragment, paths) {\n    for (var info, childNodes, updates = [], removeAttributes = [], i = 0, length = paths.length; i < length; i++) {\n      childNodes = [];\n      info = paths[i];\n      updates[i] = setContent(info.type, discoverNode(this, fragment, info, childNodes), removeAttributes, childNodes);\n    }\n    removeAttributeList(removeAttributes);\n    return updates;\n  }\n\n  // invokes each update function passing interpolated value\n  function update() {\n    for (var i = 1, length = arguments.length; i < length; i++) {\n      this[i - 1](arguments[i]);\n    }\n  }\n\n  // create a template, if unknown\n  // upgrade a node to use such template for future updates\n  function upgrade(template) {\n    if (FF) template = unique(template);\n    var updates;\n    var info = templates.get(template) || createTemplate.call(this, template);\n    if (notAdopting) {\n      var fragment = info.fragment.cloneNode(true);\n      updates = createUpdates.call(this, fragment, info.paths);\n      resetAndPopulate(this, fragment);\n    } else {\n      updates = discoverUpdates.call(this, info.fragment, info.paths);\n    }\n    return { template: template, updates: updates };\n  }\n\n  // ---------------------------------------------\n  // Wires\n  // ---------------------------------------------\n\n  // create a new wire for generic DOM content\n  function wireContent(type) {\n    var adopter, content, container, fragment, render, setup, template;\n\n    function before(document) {\n      fragment = document.createDocumentFragment();\n      container = type === 'svg' ? document.createElementNS(SVG_NAMESPACE, 'svg') : fragment;\n      render = hyperHTML.bind(container);\n    }\n\n    function after() {\n      if (setup) {\n        setup = false;\n        if (type === 'svg') {\n          appendNodes(fragment, slice.call(container.childNodes));\n        }\n        content = createContent(fragment);\n      }\n      return content;\n    }\n\n    return type === 'adopt' ? function adopt(statics) {\n      var args = arguments;\n      if (FF) statics = unique(statics);\n      if (template !== statics) {\n        setup = true;\n        template = statics;\n        adopter = function adopter(parentNode, children, i) {\n          if (setup) {\n            if (i < children.length) {\n              container = children[i];\n              fragment = {\n                ownerDocument: container.ownerDocument,\n                childNodes: [container],\n                children: [container]\n              };\n              render = hyperHTML.adopt(fragment);\n            } else {\n              if (OWNER_SVG_ELEMENT in parentNode) type = 'svg';\n              before(parentNode.ownerDocument);\n            }\n          }\n          render.apply(null, args);\n          return after();\n        };\n      }\n      return adopter;\n    } : function update(statics) {\n      if (FF) statics = unique(statics);\n      if (template !== statics) {\n        setup = true;\n        template = statics;\n        before(hyperHTML.document);\n      }\n      render.apply(null, arguments);\n      return after();\n    };\n  }\n\n  // setup a weak reference if needed and return a wire by ID\n  function wireWeakly(obj, type) {\n    var wire = wires.get(obj);\n    var i = type.indexOf(':');\n    var id = type;\n    if (-1 < i) {\n      id = type.slice(i + 1);\n      type = type.slice(0, i) || 'html';\n    }\n    if (!wire) {\n      wire = {};\n      wires.set(obj, wire);\n    }\n    return wire[id] || (wire[id] = wireContent(type));\n  }\n\n  // ---------------------------------------------\n  // ‚ö°Ô∏è Ô∏èÔ∏èThe End ‚û∞\n  // ---------------------------------------------\n  return hyperHTML;\n}(document);\n\n// umd.KISS\ntry {\n  module.exports = hyperHTML;\n} catch (o_O) {}"
    },
    {
      "id": 2,
      "identifier": "/home/webreflection/code/create-hyperhtml-app/node_modules/babel-loader/lib/index.js!/home/webreflection/code/create-hyperhtml-app/viper/view/ua-info.js",
      "name": "./viper/view/ua-info.js",
      "index": 2,
      "index2": 1,
      "size": 471,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/webreflection/code/create-hyperhtml-app/node_modules/babel-loader/lib/index.js!/home/webreflection/code/create-hyperhtml-app/viper/client/index.js",
      "issuerId": 0,
      "issuerName": "./viper/client/index.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 0,
          "moduleIdentifier": "/home/webreflection/code/create-hyperhtml-app/node_modules/babel-loader/lib/index.js!/home/webreflection/code/create-hyperhtml-app/viper/client/index.js",
          "module": "./viper/client/index.js",
          "moduleName": "./viper/client/index.js",
          "type": "cjs require",
          "userRequest": "../view/ua-info.js",
          "loc": "2:13-42"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "optimizationBailout": [],
      "depth": 1,
      "source": "var _templateObject = _taggedTemplateLiteral([\"\\n  <p>\\n    Your user agent string is: <br>\\n    \", \"\\n  </p>\\n\"], [\"\\n  <p>\\n    Your user agent string is: <br>\\n    \", \"\\n  </p>\\n\"]);\n\nfunction _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n// what does the index page represent ?\nmodule.exports = function (render, model) {\n  return render(_templateObject, model.userAgent);\n};"
    },
    {
      "id": 3,
      "identifier": "/home/webreflection/code/create-hyperhtml-app/node_modules/babel-loader/lib/index.js!/home/webreflection/code/create-hyperhtml-app/viper/client/sw.js",
      "name": "./viper/client/sw.js",
      "index": 3,
      "index2": 3,
      "size": 894,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        1
      ],
      "assets": [],
      "issuer": null,
      "issuerId": null,
      "issuerName": null,
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [],
      "usedExports": true,
      "providedExports": null,
      "optimizationBailout": [],
      "depth": 0,
      "source": "var openCache = caches.open('#[viper-news]');\nvar any = function any($) {\n  return new Promise(function (D, E, A, L) {\n    A = [];\n    L = $.map(function ($, i) {\n      return Promise.resolve($).then(D, function (O) {\n        return (A[i] = O, --L) || E(A);\n      });\n    }).length;\n  });\n};\n\nself.addEventListener('install', function (e) {\n  e.waitUntil(openCache.then(function (cache) {\n    return cache.addAll([]);\n  }));\n});\n\nself.addEventListener('fetch', function (e) {\n  var request = e.request;\n  e.respondWith(openCache.then(function (cache) {\n    return cache.match(request).then(function (response) {\n      var remote = fetch(request).then(function (response) {\n        if (199 < response.status && response.status < 400) {\n          cache.put(request, response.clone());\n        }\n        return response;\n      });\n      return any([response || remote, remote]);\n    });\n  }));\n});"
    }
  ],
  "filteredModules": 0,
  "children": []
}